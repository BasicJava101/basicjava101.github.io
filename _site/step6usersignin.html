<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
  <title>Phoenix Basics</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
</head>


<body>

    <!-- Wrapper -->
    <div id="wrapper">

        <!-- Main -->
        <div id="main">
            <div class="inner">
              <header id="header">
                <a href="http://localhost:4000/" class="logo">
                  <img src="/assets/images/conflogo.png">
                  <strong>Phoenix Basics</strong> 
                </a>
              </header>

                <!-- Content -->
                <section>
                	<header class="main">
                		<h1>Add Member Signin</h1>
                	</header>

                  

                <h3 id="add-a-signup-context">Add a Signup Context</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6.usersignin</code> to catch up with the class)</p>

<p>Now that we have a schedule let’s add the ability for members to join the site - this will allow us to let people curate their own agenda at the conference.</p>

<p>We’re going to have several user resources as part of this application - at the very least we’ll have signup, login, and profile contexts. We’ll start with signup first.</p>

<p>Paste the following in our commandline:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix phx.gen.html Signup User users username:string:unique password:string --web Signup
</code></pre></div></div>

<p>This should seem rather familiar by now - it will generate all the files for a Signup.User context.  The <code class="highlighter-rouge">web</code> flag makes Phoenix generate a namespace for the web parts.  This will help us separate our authentication resources from our signup resources (more on that later).</p>

<p>The migration that was generated will ensure a unique username:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Repo.Migrations.CreateUsers do
  use Ecto.Migration

  def change do
    create table(:users) do
      add :username, :string
      add :password, :string

      timestamps()
    end

    create unique_index(:users, [:username])
  end
end
</code></pre></div></div>

<p>If we run the migration now we’ll get an error because we’re missing the router - so let’s hold off on that a bit.</p>

<p>The generated <code class="highlighter-rouge">Fawkes.Signup</code> context will contain a lot of things we don’t need. For signup we will only need the <code class="highlighter-rouge">new</code> and <code class="highlighter-rouge">create</code> actions and related functionality - so let’s delete everything except change_user/1 and create_user/1. Since we no longer run queries in this context we can also delete the <code class="highlighter-rouge">import Ecto.Query</code> line.  The end should look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Signup do
  @moduledoc """
  The Signup context.
  """

  alias Fawkes.Repo
  alias Fawkes.Signup.User

  @doc """
  Creates a user.

  ## Examples

      iex&gt; create_user(%{field: value})
      {:ok, %User{}}

      iex&gt; create_user(%{field: bad_value})
      {:error, %Ecto.Changeset{}}

  """
  def create_user(attrs \\ %{}) do
    %User{}
    |&gt; User.changeset(attrs)
    |&gt; Repo.insert()
  end

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.

  ## Examples

      iex&gt; change_user(user)
      %Ecto.Changeset{source: %User{}}

  """
  def change_user(%User{} = user) do
    User.changeset(user, %{})
  end
end
</code></pre></div></div>

<p>We’ll do something similar to the controller - remove everything from <code class="highlighter-rouge">FawkesWeb.Signup.UserController</code> that isn’t <code class="highlighter-rouge">new/2</code> or <code class="highlighter-rouge">create/2</code>. We’ll also change the redirect on success in <code class="highlighter-rouge">create/2</code> to point to <code class="highlighter-rouge">slot_path(conn, :index)</code>. It’ll look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Signup.UserController do
  use FawkesWeb, :controller

  alias Fawkes.Signup
  alias Fawkes.Signup.User

  def new(conn, _params) do
    changeset = Signup.change_user(%User{})
    render(conn, "new.html", changeset: changeset)
  end

  def create(conn, %{"user" =&gt; user_params}) do
    case Signup.create_user(user_params) do
      {:ok, user} -&gt;
        conn
        |&gt; put_flash(:info, "User created successfully.")
        |&gt; redirect(to: slot_path(conn, :index))
      {:error, %Ecto.Changeset{} = changeset} -&gt;
        render(conn, "new.html", changeset: changeset)
    end
  end
end
</code></pre></div></div>

<p>Next we’ll remove the templates we don’t need - delete <code class="highlighter-rouge">templates/signup/user/edit.html.eex</code>, <code class="highlighter-rouge">templates/signup/user/index.html.eex</code>, and <code class="highlighter-rouge">templates/signup/user/show.html.eex</code>. There is also a <code class="highlighter-rouge">Back</code> link in our <code class="highlighter-rouge">templates/signup/user/new.html.eex</code> template that points to a route we’re not going to have yet. Let’s delete the line. Change the <code class="highlighter-rouge">h2</code> title to <code class="highlighter-rouge">Create Account</code>. Wrap the HTML in a div with a class named <code class="highlighter-rouge">container</code>. The result looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div class="container"&gt;
  &lt;h2&gt;Create Account&lt;/h2&gt;

  &lt;%= render "form.html", Map.put(assigns, :action, signup_user_path(@conn, :create)) %&gt;
&lt;/div&gt;
</code></pre></div></div>

<p>Now that we’ve removed what we don’t need we can add what we do need.</p>

<p>First - passwords should use an HTML input element with the <code class="highlighter-rouge">type=password</code> attribute.  Open <code class="highlighter-rouge">templates/signup/user/form.html.eex</code> and change our password <code class="highlighter-rouge">text_input</code> to <code class="highlighter-rouge">password_input</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;%= password_input f, :password, class: "form-control" %&gt;
</code></pre></div></div>

<p>Now we’ll add the resources to our router - let’s have a the url for a new user be “localhost:4000/signup/new”. The generator suggests using a scope - we’ll copy and paste the suggested code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    scope "/signup", FawkesWeb.Signup, as: :signup do
      pipe_through :browser

      resources "/users", UserController
    end
</code></pre></div></div>

<p>This makes our url for <code class="highlighter-rouge">UserController</code> “localhost:4000/signup/users/new”… close - but let’s remove the <code class="highlighter-rouge">users</code> segment.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      resources "/", UserController, only: [:new, :create]
</code></pre></div></div>

<p>Path helpers look at the names of modules (as opposed to the url strings) to name our paths - so this change will not affect anything the generator created.</p>

<p>Now that we have a the router updated we can run our migration with <code class="highlighter-rouge">mix ecto.migrate</code>.</p>

<h3 id="hash-and-validate-passwords">Hash and Validate Passwords</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6a.password</code> to catch up with the class)</p>

<p>We can now signup new users! We can improve things a bit with some validators… and we really should hash our passwords before we store them. All that happens will happen in <code class="highlighter-rouge">Fawkes.Signup.User.changeset/2</code>.</p>

<p>We’ll start by adding an encryption library.  There are a ton of great libraries available through hex (see <a href="https://github.com/riverrun/comeonin/wiki/Choosing-the-password-hashing-algorithm">Riverrun’s choosing the password algorithm</a> for examples).  We’ll use bcrypt_elixir by adding it (and comeonin) to our <code class="highlighter-rouge">mix.exs</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  defp deps do
    [
      {:phoenix, "~&gt; 1.3.2"},
      {:phoenix_pubsub, "~&gt; 1.0"},
      {:phoenix_ecto, "~&gt; 3.2"},
      {:postgrex, "&gt;= 0.0.0"},
      {:phoenix_html, "~&gt; 2.10"},
      {:phoenix_live_reload, "~&gt; 1.0", only: :dev},
      {:gettext, "~&gt; 0.11"},
      {:cowboy, "~&gt; 1.0"},

      # For datetime formating
      {:timex, "~&gt; 3.3"},

      # For authentication
      {:bcrypt_elixir, "~&gt; 1.0"},
      {:comeonin, "~&gt;4.0"},
    ]
  end
</code></pre></div></div>

<p>… and runing <code class="highlighter-rouge">mix deps.get</code> on our commandline.</p>

<p>Now we’ll edit our Fawkes.Signup.User.changeset/2 - add a step in our pipeline which calls a private method to replace our plain text password with a hashed version.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  @doc false
  def changeset(user, attrs) do
    user
    |&gt; cast(attrs, [:username, :password])
    |&gt; validate_required([:username, :password])
    |&gt; unique_constraint(:username)
    |&gt; put_pass_hash()
  end
</code></pre></div></div>

<p>This method takes and returns a changeset. We can transform a changeset using <code class="highlighter-rouge">Ecto.Changeset.change/2</code> (available as just <code class="highlighter-rouge">change/2</code> because we import <code class="highlighter-rouge">Ecto.Changeset</code>). We’ll use a pattern match in the method signature to so that when a changeset is valid we hash the password with <code class="highlighter-rouge">Comeonin.Bcrypt.hashpwsalt/1</code>.  If the pattern match fails we’ll change the password to an empty string:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  defp put_pass_hash(%{valid?: true, changes: params} = changeset) do
    password = Comeonin.Bcrypt.hashpwsalt(params[:password])
    change(changeset, password: password)
  end

  defp put_pass_hash(changeset) do
    change(changeset, password: "")
  end
</code></pre></div></div>

<p>While we’re here let’s add a few other useful validators to our changeset - we can do things like blacklist passwords with <code class="highlighter-rouge">validate_exclusion</code> or ensure the length of the password with <code class="highlighter-rouge">validate_length</code>. The resulting schema will look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Signup.User do
  use Ecto.Schema
  import Ecto.Changeset

  @bad_passwords ~w(
    12345678
    password1
    qwertyuiop
  )

  schema "users" do
    field :password, :string
    field :username, :string

    timestamps()
  end

  @doc false
  def changeset(user, attrs) do
    user
    |&gt; cast(attrs, [:username, :password])
    |&gt; validate_required([:username, :password])
    |&gt; unique_constraint(:username)
    |&gt; validate_exclusion(
         :password,
         @bad_passwords,
         message: "That password is too common.")
    |&gt; validate_length(:password, min: 8)
    |&gt; put_pass_hash()
  end

  defp put_pass_hash(%{valid?: true, changes: params} = changeset) do
    password = Comeonin.Bcrypt.hashpwsalt(params[:password])
    change(changeset, password: password)
  end

  defp put_pass_hash(changeset) do
    change(changeset, password: "")
  end
end
</code></pre></div></div>

<p>You can read more on validations on the <a href="https://hexdocs.pm/ecto/Ecto.Changeset.html">Ecto.Changeset Hexdocs</a>.</p>

<h3 id="add-an-auth-context">Add an Auth Context</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6b.auth</code> to catch up with the class)</p>

<p>Now that we can sign up we need to be able to log in. The process will be almost identical.  Start with the generator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mix phx.gen.html Auth User users username:string password:string --web Auth
</code></pre></div></div>

<p>This time we can delete the migration (since our new context will just use the same users table we generated before.)</p>

<p>We don’t create anything when a user logs in - so delete everything except <code class="highlighter-rouge">change_user/1</code> from the <code class="highlighter-rouge">Fawkes.Auth</code> context.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Auth do
  @moduledoc """
  The Auth context.
  """

  alias Fawkes.Auth.User

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.

  ## Examples

      iex&gt; change_user(user)
      %Ecto.Changeset{source: %User{}}

  """
  def change_user(%User{} = user) do
    User.changeset(user, %{})
  end
end
</code></pre></div></div>

<p>Remove everything but <code class="highlighter-rouge">new/2</code> and <code class="highlighter-rouge">create/2</code> from <code class="highlighter-rouge">FawkesWeb.Auth.UserController</code>.  (We’ll eventually need a <code class="highlighter-rouge">delete/2</code>) but the implementation is different so we’ll delete the generated default. Change the redirect on successs in <code class="highlighter-rouge">create/2</code> to <code class="highlighter-rouge">slot_path(conn, :index)</code>.  The result will look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Auth.UserController do
  use FawkesWeb, :controller

  alias Fawkes.Auth
  alias Fawkes.Auth.User

  def new(conn, _params) do
    changeset = Auth.change_user(%User{})
    render(conn, "new.html", changeset: changeset)
  end

  def create(conn, %{"user" =&gt; user_params}) do
    case Auth.create_user(user_params) do
      {:ok, user} -&gt;
        conn
        |&gt; put_flash(:info, "User created successfully.")
        |&gt; redirect(to: slot_path(conn, :index))
      {:error, %Ecto.Changeset{} = changeset} -&gt;
        render(conn, "new.html", changeset: changeset)
    end
  end
end

</code></pre></div></div>

<p>Delete <code class="highlighter-rouge">templates/auth/user/edit.html.eex</code>, <code class="highlighter-rouge">templates/auth/user/index.html.eex</code>, and <code class="highlighter-rouge">templates/auth/user/show.html.eex</code>. Remove the <code class="highlighter-rouge">Back</code> link in our <code class="highlighter-rouge">templates/auth/user/new.html.eex</code>. Add a div with the class <code class="highlighter-rouge">container</code> around it. Change the title to <code class="highlighter-rouge">Log in</code>. The final result looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div class="container"&gt;
  &lt;h2&gt;Log in&lt;/h2&gt;
  &lt;%= render "form.html", Map.put(assigns, :action, auth_user_path(@conn, :create)) %&gt;
&lt;/div&gt;

</code></pre></div></div>

<p>Change the input in <code class="highlighter-rouge">templates/auth/user/form.html.eex</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;%= password_input f, :password, class: "form-control" %&gt;
</code></pre></div></div>

<p>Next we’ll return to the Fawkes.Auth context and add an <code class="highlighter-rouge">authenticate_user/2</code> method.  This method contain a pipeline to that takes the params and returns a boolean indicating whether the user/password combo is authentic.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def authenticate_user(%{"username" =&gt; user, "password" =&gt; pass}) do
  user
  |&gt; fetch_user_by_username()
  |&gt; check_password(pass)
end
</code></pre></div></div>

<p><code class="highlighter-rouge">fetch_user_by username()</code> is a simple ecto query:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import Ecto.Query, warn: false
alias Fawkes.Repo

# . . .

def fetch_user_by_username(username) do
  User
  |&gt; where([user], user.username == ^username)
  |&gt; Repo.one
end
</code></pre></div></div>

<p>For <code class="highlighter-rouge">check_password/2</code> we’ll pattern match to ensure that if we don’t have a user we just return false:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  defp check_password(%User{} = user, password) do
    # Check the password
  end

  defp check_password(_, _), do: {:error, :incorrect}
</code></pre></div></div>

<p>… and then leverage <code class="highlighter-rouge">Comeonin.Bcrypt.checkpw/2</code> to check the given password against the password on the found user.  If it succeeds we’ll return an :ok tagged tuple… otherwise we’ll return an :error tagged tuple after running <code class="highlighter-rouge">Comeonin.Bcrypt.dummy_checkpw/0</code>.  (<code class="highlighter-rouge">dummy_checkpw/0</code> defends against <a href="https://en.wikipedia.org/wiki/Timing_attack">timing attacks</a>.) Alias Bcrypt and add the check password function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  alias Comeonin.Bcrypt

  # . . .

  defp check_password(%User{} = user, password) do
    password
    |&gt; Bcrypt.checkpw(user.password)
    |&gt; case do
      true -&gt;
        {:ok, user}
      false -&gt;
        Bcrypt.dummy_checkpw()
        {:error, :incorrect}
    end
  end
</code></pre></div></div>

<p>Our final result will look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Auth do
  @moduledoc """
  The Auth context.
  """

  import Ecto.Query, warn: false
  alias Comeonin.Bcrypt
  alias Fawkes.Auth.User
  alias Fawkes.Repo

  @doc """
  Returns an `%Ecto.Changeset{}` for tracking user changes.

  ## Examples

      iex&gt; change_user(user)
      %Ecto.Changeset{source: %User{}}

  """
  def change_user(%User{} = user) do
    User.changeset(user, %{})
  end

  def authenticate_user(%{"username" =&gt; user, "password" =&gt; pass}) do
    user
    |&gt; fetch_user_by_username()
    |&gt; check_password(pass)
  end

  defp fetch_user_by_username(username) do
    User
    |&gt; where([user], user.username == ^username)
    |&gt; Repo.one
  end

  defp check_password(%User{} = user, password) do
    password
    |&gt; Bcrypt.checkpw(user.password)
    |&gt; case do
      true -&gt;
        {:ok, user}
      false -&gt;
        Bcrypt.dummy_checkpw()
        {:error, :incorrect}
    end
  end

  defp check_password(_, _), do: false
end
</code></pre></div></div>

<p>Now we can change our <code class="highlighter-rouge">FawkesWeb.Auth.UserController</code> to leverage <code class="highlighter-rouge">authenticate_user/1</code> (instead of the non-existent <code class="highlighter-rouge">Auth.create_user/1</code>)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Auth.UserController do
  use FawkesWeb, :controller

  alias Fawkes.Auth
  alias Fawkes.Auth.User

  def new(conn, _params) do
    changeset = Auth.change_user(%User{})
    render(conn, "new.html", changeset: changeset)
  end

  def create(conn, %{"user" =&gt; user_params}) do
    case Auth.authenticate_user(user_params) do
      {:ok, user} -&gt;
        conn
        |&gt; put_flash(:info, "User created successfully.")
        |&gt; redirect(to: slot_path(conn, :index))
      {:error, %Ecto.Changeset{} = changeset} -&gt;
        render(conn, "new.html", changeset: changeset)
    end
  end
end

</code></pre></div></div>

<h3 id="add-a-membership-context">Add a Membership Context</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6c.membership</code> to catch up with the class)</p>

<p>Now that we’re able to assess whether a user is authentic we need to make that information available to our controllers somehow. We need a user data type to leverage outside the Auth and Signup contexts.  This new user context will lack access to <code class="highlighter-rouge">password</code> and will give us a place to relate profiles and agendas without muddying the data types we use to signin and authenticate. To pull this off we’ll generate a new <code class="highlighter-rouge">Membership</code> context.  First the <code class="highlighter-rouge">User</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Membership.User do
  use Ecto.Schema

  schema "users" do
    field(:username, :string)

    timestamps()
  end
end
</code></pre></div></div>

<p>And then a context with a method to find those users based on their id:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule Fawkes.Membership do
  @moduledoc """
  Context responsible for managing profile information
  """

  import Ecto.Query
  alias Fawkes.Membership.User
  alias Fawkes.Repo

  def get_user(id) do
    User
    |&gt; where([user], user.id == ^id)
    |&gt; Repo.one()
  end
end
</code></pre></div></div>

<h3 id="sign-and-verify-or-reject-authentication-tokens">Sign and Verify (or reject) Authentication Tokens</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6d.signin</code> to catch up with the class)</p>

<p>Now that we’ve defined <code class="highlighter-rouge">Fawkes.Membership.User</code> to use throughout the app - we need to figure out how to keep that data handy in a session once the user has authenticated.  For that we’ll use Guardian - library that signs and verifies <a href="https://jwt.io/">JSON Web Tokens</a>. That topic is <em>deep</em> so we’re gonna accept the magic here. For now - Guardian is how we’ll log people in. We’ll add it (and Comeonin as a dependency) to our <code class="highlighter-rouge">mix.exs</code> file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defp deps do
  [
    {:phoenix, "~&gt; 1.3.2"},
    {:phoenix_pubsub, "~&gt; 1.0"},
    {:phoenix_ecto, "~&gt; 3.2"},
    {:postgrex, "&gt;= 0.0.0"},
    {:phoenix_html, "~&gt; 2.10"},
    {:phoenix_live_reload, "~&gt; 1.0", only: :dev},
    {:gettext, "~&gt; 0.11"},
    {:cowboy, "~&gt; 1.0"},

    # For datetime formating
    {:timex, "~&gt; 3.3"},

    # For authentication
    {:bcrypt_elixir, "~&gt; 1.0"},
    {:comeonin, "~&gt; 4.0"},
    {:guardian, "~&gt; 1.0"},
  ]
end
</code></pre></div></div>

<p>…then run <code class="highlighter-rouge">mix deps.get</code> in our terminal.</p>

<p>Guardian requires a bit of setup.</p>

<p>First we need to create something to parse token information.  According to the documentation this module needs to <code class="highlighter-rouge">use</code> Guardian and implement two methods.  <code class="highlighter-rouge">subject_for_token/2</code> needs to generate a value in session which can later be used to look up a user.  We’ll use the user’s id so we can leverage that <code class="highlighter-rouge">Fawkes.Membership.get_user/1</code> method we created.  Then we need a <code class="highlighter-rouge">resource_from_claims/1</code> which takes the id (called a “sub” … short for “subject”) and returns a Fawkes.Membership.User.  We can then access that user in our application.</p>

<p>This module will be responsible for translating iodata from the web - so let’s create <code class="highlighter-rouge">FawkesWeb.Guardian.Tokenizer</code> in the <code class="highlighter-rouge">lib/fawkes_web/guardian</code> folder - adding <code class="highlighter-rouge">use Guardian, otp_app: &lt;app_name&gt;</code> the way the documentation asks:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Guardian.Tokenizer do
  use Guardian, otp_app: :fawkes
end
</code></pre></div></div>

<p>Then add to it our <code class="highlighter-rouge">subject_for_token/2</code>.  Later on we’ll hand it a Signup or Auth User and it needs to return an :ok tagged tuple containing the id of the given user as a string.:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def subject_for_token(%{id: id}, _) do
    {:ok, to_string(id)}
  end
</code></pre></div></div>

<p>Then we add <code class="highlighter-rouge">resource_from_claims/1</code> - this will need to return with an :ok tagged tuple with the Membership User or an :error tagged tuple.  Guardian will hand it a JWT “claim” - which will (by convention) store our token subject (the id) in a key called <code class="highlighter-rouge">"sub"</code>. Add <code class="highlighter-rouge">alias Fawkes.Membership</code>. Then add this function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def resource_from_claims(claims) do
  case Membership.get_user(claims["sub"]) do
    nil -&gt; {:error, :resource_not_found}
    user -&gt; {:ok, user}
  end
end
</code></pre></div></div>

<p>The resulting module should look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Guardian.Tokenizer do
  use Guardian, otp_app: :fawkes
  alias Fawkes.Membership

  def subject_for_token(%{id: id}, _) do
    {:ok, to_string(id)}
  end

  def resource_from_claims(claims) do
    case Membership.get_user(claims["sub"]) do
      nil -&gt; {:error, :resource_not_found}
      user -&gt; {:ok, user}
    end
  end
end
</code></pre></div></div>

<p>Next we have some configuration to do - handing guardian a secret key to use for encryption and telling it where our Token logic lives. Run <code class="highlighter-rouge">mix phx.gen.secret</code> to get a random string to use for this - then in both <code class="highlighter-rouge">config/dev.exs</code> and <code class="highlighter-rouge">config/test.exs</code> add the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config :fawkes, FawkesWeb.Guardian.Tokenizer,
                issuer: "fawkes",
                secret_key: "our random string"
</code></pre></div></div>

<p>Then in <code class="highlighter-rouge">config/prod.exs</code> we’ll want to leverage environment vars for our secret key for security:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config :fawkes,
       FawkesWeb.Guardian.Tokenizer,
       issuer: "fawkes",
       secret_key: Map.fetch!(System.get_env(),
                              "GUARDIAN_KEY")
</code></pre></div></div>

<p>(If you’ve got phx.server running you’ll need to restart it to see this change.)</p>

<p>Now we’re ready to sign our JWT.  In <code class="highlighter-rouge">FawkesWeb.Auth.UserController</code> we’ll do that by calling a method from a meta-programmed module Guardian creates called <code class="highlighter-rouge">FawkesWeb.Guardian.Tokenizer.Plug.sign_in/2</code>. Add this line <code class="highlighter-rouge">|&gt; GuardianPlug.sign_in(user)
</code> below the flash message in the create function. The result (after some alias goodness) looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Auth.UserController do
  use FawkesWeb, :controller

  alias Fawkes.Auth
  alias Fawkes.Auth.User
  alias FawkesWeb.Guardian.Tokenizer.Plug, as: GuardianPlug

  def new(conn, _params) do
    changeset = Auth.change_user(%User{})
    render(conn, "new.html", changeset: changeset)
  end

  def create(conn, %{"user" =&gt; user_params}) do
    case Auth.create_user(user_params) do
      {:ok, user} -&gt;
        conn
        |&gt; put_flash(:info, "User created successfully.")
        |&gt; GuardianPlug.sign_in(user)
        |&gt; redirect(to: slot_path(conn, :index))
      {:error, %Ecto.Changeset{} = changeset} -&gt;
        render(conn, "new.html", changeset: changeset)
    end
  end
end
</code></pre></div></div>

<p>While we’re here let’s add a <code class="highlighter-rouge">delete/2</code> action to allow us to logout. This will call <code class="highlighter-rouge">FawkesWeb.Guardian.Tokenizer.Plug.sign_out/2</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def delete(conn, _) do
  conn
  |&gt; GuardianPlug.sign_out()
  |&gt; redirect(to: page_path(conn, :index))
end
</code></pre></div></div>

<p>We’ll come back to delete later - for now let’s add login new and create to our routes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  scope "/login", FawkesWeb.Auth, as: :auth do
    pipe_through :browser

    resources "/", UserController, only: [:new, :create]
  end

</code></pre></div></div>

<h3 id="adding-a-plug-pipelines-for-authentication">Adding a Plug Pipelines for Authentication</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6e.auth_pipeline</code> to catch up with the class)</p>

<p>Ok - now we can sign and unsign authentication tokens… but to make the resource available we need to add a plug.</p>

<p>Plug is the core of the Phoenix Framework. It defines a type - called a Connection Struct (or conn) which is passed through a “plug pipeline”. The connection struct holds the state of the request - and is transformed at each step of the pipeline. For most pages on the site we want Guardian to add verify the JWT we created during signup and then add it to the conn for later use.</p>

<p>Ok… a personal note - Phoenix isn’t super magical… but Guardian kinda is. Getting in to why this thing works the way it does is probably not “basic” - so I’m gonna get hand wavy here.  Follow along and it will probably make more sense in a couple minutes.  Ask questions if you have them - and plan to come back and read the documentation for Guardian at some point in the future to get a better understanding.</p>

<p>To do that we first need to tell Guardian how to handle an invalid JWT. Following the documentation - this module we generate needs to implement an <code class="highlighter-rouge">auth_error/3</code> method. We’ll just use the boilerplate provided by the documentation and add the following to <code class="highlighter-rouge">lib/fawkes_web/guardian/error_handler.ex</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Guardian.ErrorHandler do
  @moduledoc """
  Logic for handling errors during the auth process
  """

  import Plug.Conn

  def auth_error(conn, {type, _reason}, _opts) do
    conn
    |&gt; put_resp_content_type("text/plain")
    |&gt; send_resp(401, to_string(type))
  end
end
</code></pre></div></div>

<p>Now we can generate a module to act as plug pipeline for Guardian to verify tokens. Following documentation we’ll add a <code class="highlighter-rouge">lib/fawkes_web/guardian/plug.ex</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Guardian.Plug do
  @moduledoc """
  Pipeline which ensures a user is authenticated
  """

  use Guardian.Plug.Pipeline,
      otp_app: :fawkes,
      error_handler: FawkesWeb.Guardian.ErrorHandler,
      module: FawkesWeb.Guardian.Tokenizer

  # If there is a session token, validate it
  plug(Guardian.Plug.VerifySession, claims: %{"typ" =&gt; "access"})

  # If there is an authorization header, validate it
  plug(Guardian.Plug.VerifyHeader, claims: %{"typ" =&gt; "access"})

  # Load the user if either of the verifications worked
  plug(Guardian.Plug.LoadResource, allow_blank: true)
end
</code></pre></div></div>

<p>Adding this plug to a pipeline (back to that in a sec) will verify the request and stash the information in our connection struct.  We’ll have a method available, <code class="highlighter-rouge">FawkesWeb.Guardian.Tokenizer.Plug.current_resource/1</code>, which takes our conn and returns the Membership User. We can generate a plug of our own (in <code class="highlighter-rouge">lib/fawkes_web/guardian/current_user_plug.ex</code>) to place this in an easier-to-access location using Plug.Conn.assign/3:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Guardian.CurrentUserPlug do
  @moduledoc """
  Plug that populates the current_user assigns
  """

  alias FawkesWeb.Guardian.Tokenizer.Plug, as: GuardianPlug
  alias Plug.Conn

  def init(opts), do: opts

  def call(conn, _opts) do
    Conn.assign(conn, :current_user, GuardianPlug.current_resource(conn))
  end
end
</code></pre></div></div>

<p>Once we use this we can get our current_user by using <code class="highlighter-rouge">conn.assigns.current_user</code>.</p>

<h3 id="using-our-new-pipelines-in-the-router">Using Our New Pipelines in the Router</h3>
<p>(Use <code class="highlighter-rouge">git checkout 6f.router_pipeline</code> to catch up with the class)</p>

<p>That was a lot - let’s set up our router and then show it in action. In the router we’ll create a new pipeline called guardian which uses the two plugs we just created to verify JWTs:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  pipeline :guardian do
    plug FawkesWeb.Guardian.Plug
    plug FawkesWeb.Guardian.CurrentUserPlug
  end
</code></pre></div></div>

<p>Then we’ll create another pipeline to force authentication - this will leverage a default plug from Guardian which will use the error handler module we created if no verified JWT is found.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  pipeline :ensure_auth do
    plug Guardian.Plug.EnsureAuthenticated
  end
</code></pre></div></div>

<p>The order of these is important - we’ll need our :ensure_auth pipeline to only run <em>after</em> the :guardian pipeline (otherwise the connection struct will not have a verified token yet).  We’ll only want to let users logout if they are authenticated - so let’s try that out with a logout route:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  scope "/", FawkesWeb do
    pipe_through [:browser, :guardian, :ensure_auth]
    post("/logout", Auth.UserController, :delete)
  end
</code></pre></div></div>

<p>And add just the guardian pipeline to the rest of our routes (so we have current_user available)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  scope "/", FawkesWeb do
    pipe_through [:browser, :guardian]

    # ...
  end

  scope "/signup", FawkesWeb.Signup, as: :signup do
    pipe_through [:browser, :guardian]

    # ...
  end

  scope "/login", FawkesWeb.Auth, as: :auth do
    pipe_through [:browser, :guardian]

    # ...
  end
</code></pre></div></div>

<p>The result should look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defmodule FawkesWeb.Router do
  use FawkesWeb, :router

  pipeline :browser do
    plug :accepts, ["html"]
    plug :fetch_session
    plug :fetch_flash
    plug :protect_from_forgery
    plug :put_secure_browser_headers
  end

  pipeline :api do
    plug :accepts, ["json"]
  end

  pipeline :guardian do
    plug FawkesWeb.Guardian.Plug
    plug FawkesWeb.Guardian.CurrentUserPlug
  end

  pipeline :ensure_auth do
    plug Guardian.Plug.EnsureAuthenticated
  end

  scope "/", FawkesWeb do
    pipe_through [:browser, :guardian, :ensure_auth]
    post("/logout", PageController, :logout)
  end

  scope "/", FawkesWeb do
    pipe_through [:browser, :guardian]

    get "/", PageController, :index

    resources("/schedule", ScheduleController, only: [:index, :show])
    resources("/audience", AudienceController, only: [:show])
    resources("/category", CategoryController, only: [:show])
    resources("/location", LocationController, only: [:show])
    resources("/speaker", SpeakerController, only: [:index, :show])
    resources("/talk", TalkController, only: [:show])
  end

  scope "/signup", FawkesWeb.Signup, as: :signup do
    pipe_through [:browser, :guardian]

    resources "/", UserController, only: [:new, :create]
  end

  scope "/login", FawkesWeb.Auth, as: :auth do
    pipe_through [:browser, :guardian]

    resources "/", UserController, only: [:new, :create]
  end

  # Other scopes may use custom stacks.
  # scope "/api", FawkesWeb do
  #   pipe_through :api
  # end
end
</code></pre></div></div>

<h3 id="adding-authentication-links-to-the-layout">Adding Authentication Links to the Layout</h3>

<p>Finally we need to add links so that users can access signup, login and logout globally.  In our <code class="highlighter-rouge">lib/fawkes_web/templates/layout/app.html.eex</code> render a partial. After the link for talk (maybe line 31), add this code to render a partial for session list.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;%= render(__MODULE__, "session_list_items.html", conn: @conn) %&gt;
</code></pre></div></div>

<p>Create a new file in the layout template folder <code class="highlighter-rouge">lib/fawkes_web/templates/layout/session_list_items.html.eex</code>. Add the following code to create an account and login.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;%= if is_nil @conn.assigns[:current_user] do %&gt;
  &lt;li&gt;&lt;%= link gettext("Create Account"), to: signup_user_path(@conn, :new) %&gt;&lt;/li&gt;
  &lt;li&gt;&lt;%= link gettext("Log In"), to: auth_user_path(@conn, :new) %&gt;&lt;/li&gt;
&lt;% else %&gt;
  &lt;li&gt;&lt;%= link gettext("Logout"), to: user_path(@conn, :delete), method: :post%&gt;&lt;/li&gt;
&lt;% end %&gt;
</code></pre></div></div>


              </div>
          </div>

          <!-- Sidebar -->
  <div id="sidebar">
    <div class="inner">
      <!-- Menu -->
        <nav id="menu">
          <header class="major">
            <h2>Menu</h2>
          </header>
          <ul>
            <li><a href="index.html">0. Getting started</a></li>
            <li><a href="step1newapp.html">1. Create new project</a></li>
            <li><a href="step2addpage.html">2. Add a new page</a></li>
            <li><a href="step3addcategory.html">3. Add a feature</a></li>
            <li><a href="step3addcategoryanswer.html">3a. Add a feature answer</a></li>
            <li><a href="step4phoenixgenerator.html">4. Phoenix Generator</a></li>
            <li><a href="step5seed.html">5. Populate the database</a></li>
            <li><a href="step5seedanswer.html">5. Populate the database answer</a></li>
            <li><a href="step6usersignin.html">6. Add Member Signup</a></li>
            <li><a href="step7userprofiles.html">7. Add User Profiles</a></li>
            <li><a href="step8agenda.html">8. Add agenda</a></li>
            <li><a href="step9deploy.html">9. Deploy</a></li>
            <li><a href="step10bonus.html">10. Bonus exercise</a></li>
          </ul>
        </nav>

      <!-- Footer -->
        <footer id="footer">
          <p class="copyright">&copy; Phoenix Basics. All rights reserved. Demo Images: <a href="https://unsplash.com">Unsplash</a>. Design: <a href="https://html5up.net">HTML5 UP</a>. Jekyll integration: <a href="https://andrewbanchi.ch">Andrew Banchich</a>.</p>
        </footer>

    </div>
  </div>


      </div>

      <!-- Scripts -->
  <script src="http://localhost:4000/assets/js/jquery.min.js"></script>
  <script src="http://localhost:4000/assets/js/skel.min.js"></script>
  <script src="http://localhost:4000/assets/js/util.js"></script>
  <!--[if lte IE 8]><script src="http://localhost:4000/assets/js/ie/respond.min.js"></script><![endif]-->
  <script src="http://localhost:4000/assets/js/main.js"></script>


</body>

</html>
